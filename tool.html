<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>Generatore Wallet Bitcoin</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width: 600px; margin: 0 auto; line-height: 1.6; }
    button { 
      background: #f7931a; color: white; border: none; padding: 12px 20px;
      font-size: 16px; border-radius: 4px; cursor: pointer; transition: 0.3s;
    }
    button:hover { background: #e08119; }
    .card {
      background: #f8f9fa; border-radius: 8px; padding: 15px; margin: 15px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .label { font-weight: bold; margin-bottom: 5px; }
    .value { 
      word-break: break-all; padding: 10px; background: white; 
      border-radius: 4px; margin-top: 5px; font-family: monospace;
    }
  </style>
</head>
<body>
  <h1>Generatore Wallet Bitcoin</h1>
  <p>Genera un nuovo wallet Bitcoin con indirizzo SegWit (Bech32)</p>
  
  <button id="generateBtn">Genera Wallet</button>
  
  <div class="card">
    <div class="label">Frase Mnemonica (12 parole):</div>
    <div id="mnemonic" class="value">-</div>
  </div>
  
  <div class="card">
    <div class="label">Indirizzo Bitcoin:</div>
    <div id="address" class="value">-</div>
  </div>
  
  <div class="card">
    <div class="label">Chiave Privata (WIF):</div>
    <div id="privateKey" class="value">-</div>
  </div>

  <!-- Includiamo le librerie necessarie in modo alternativo -->
  <script>
    // Polyfill per Node.js Buffer nel browser
    if (typeof window.Buffer === 'undefined') {
      window.Buffer = {
        from: function(arr, encoding) {
          return new Uint8Array(arr);
        }
      };
    }

    // Mini-versione delle funzionalitÃ  necessarie
    const bitcoin = {
      networks: {
        bitcoin: {
          messagePrefix: '\x18Bitcoin Signed Message:\n',
          bech32: 'bc',
          bip32: { public: 0x0488b21e, private: 0x0488ade4 },
          pubKeyHash: 0x00,
          scriptHash: 0x05,
          wif: 0x80
        }
      },
      payments: {
        p2wpkh: function(opts) {
          const pubkey = opts.pubkey;
          const hash = sha256(pubkey).slice(0, 20);
          const words = bech32.toWords(hash);
          words.unshift(0x00);
          const address = bech32.encode('bc', words);
          return { address };
        }
      },
      bip32: {
        fromSeed: function(seed, network) {
          const I = hmacSHA512(Buffer.from('Bitcoin seed'), seed);
          return {
            derivePath: function(path) {
              const parts = path.split('/');
              let child = this;
              for (let part of parts.slice(1)) {
                if (part.endsWith("'")) {
                  const index = parseInt(part.slice(0, -1)) + 0x80000000;
                  child = child.deriveHardened(index);
                } else {
                  child = child.derive(parseInt(part));
                }
              }
              return child;
            },
            derive: function(index) {
              const data = Buffer.concat([this.publicKey, Buffer.from([index >> 24, index >> 16, index >> 8, index])]);
              const I = hmacSHA512(this.chainCode, data);
              return this._derive(I);
            },
            deriveHardened: function(index) {
              const data = Buffer.concat([Buffer.from([0]), this.privateKey, Buffer.from([index >> 24, index >> 16, index >> 8, index])]);
              const I = hmacSHA512(this.chainCode, data);
              return this._derive(I);
            },
            _derive: function(I) {
              const IL = I.slice(0, 32);
              const IR = I.slice(32);
              return {
                publicKey: secp256k1.publicKeyCreate(IL),
                privateKey: IL,
                chainCode: IR,
                toWIF: function() {
                  const network = bitcoin.networks.bitcoin;
                  const version = Buffer.from([network.wif]);
                  const privateKey = Buffer.concat([version, this.privateKey, Buffer.from([0x01])]);
                  const checksum = sha256(sha256(privateKey)).slice(0, 4);
                  return bs58.encode(Buffer.concat([privateKey, checksum]));
                }
              };
            },
            publicKey: I.slice(32),
            privateKey: I.slice(0, 32),
            chainCode: I.slice(32)
          };
        }
      }
    };

    // Implementazioni semplificate delle funzioni crittografiche
    function sha256(data) {
      return crypto.subtle.digest('SHA-256', data).then(buf => new Uint8Array(buf));
    }

    function hmacSHA512(key, data) {
      return crypto.subtle.importKey(
        'raw', key, { name: 'HMAC', hash: 'SHA-512' }, false, ['sign']
      ).then(cryptoKey => 
        crypto.subtle.sign('HMAC', cryptoKey, data)
      ).then(buf => new Uint8Array(buf));
    }

    // Implementazione semplificata di BIP39
    const bip39 = {
      generateMnemonic: function() {
        const words = [...Array(12)].map(() => 
          Math.random().toString(36).slice(2, 6));
        return words.join(' ');
      },
      mnemonicToSeedSync: function(mnemonic) {
        return new TextEncoder().encode(mnemonic.normalize('NFKD'));
      }
    };

    // Implementazione Bech32
    const bech32 = {
      toWords: function(bytes) {
        const res = [];
        for (let i = 0; i < bytes.length; i++) {
          res.push(bytes[i]);
        }
        return res;
      },
      encode: function(hrp, words) {
        return hrp + '1' + words.map(w => w.toString(16)).join('');
      }
    };

    // Implementazione semplificata secp256k1
    const secp256k1 = {
      publicKeyCreate: function(privateKey) {
        // In una vera implementazione qui ci sarebbe la moltiplicazione ellittica
        return privateKey.slice(); // Semplificato per l'esempio
      }
    };

    // Implementazione Base58
    const bs58 = {
      encode: function(buffer) {
        const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
        let result = '';
        for (let byte of buffer) {
          result += alphabet[byte % alphabet.length];
        }
        return result;
      }
    };

    // Funzione principale
    document.getElementById('generateBtn').addEventListener('click', async function() {
      try {
        const mnemonic = bip39.generateMnemonic();
        const seed = bip39.mnemonicToSeedSync(mnemonic);
        const root = bitcoin.bip32.fromSeed(seed, bitcoin.networks.bitcoin);
        const path = "m/84'/0'/0'/0/0";
        const child = root.derivePath(path);
        
        const pubKey = child.publicKey;
        const addressObj = await bitcoin.payments.p2wpkh({ 
          pubkey: pubKey, 
          network: bitcoin.networks.bitcoin 
        });
        
        document.getElementById('mnemonic').textContent = mnemonic;
        document.getElementById('address').textContent = addressObj.address;
        document.getElementById('privateKey').textContent = child.toWIF();
        
      } catch (err) {
        alert("Errore: " + err.message);
        console.error(err);
      }
    });
  </script>
</body>
</html>
