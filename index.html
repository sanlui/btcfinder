<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Advanced Bitcoin Explorer with real-time price charts, transaction details, block information, and address tracking">
  <meta name="keywords" content="Bitcoin, BTC, blockchain explorer, cryptocurrency, Bitcoin price, Bitcoin transactions">
  <meta name="author" content="Bitcoin Explorer">
  <meta property="og:title" content="Advanced Bitcoin Explorer">
  <meta property="og:description" content="Explore Bitcoin transactions, blocks, addresses and real-time price data">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://yourwebsite.com/bitcoin-explorer">
  <meta name="twitter:card" content="summary_large_image">
  <title>Advanced Bitcoin Explorer | Real-time Blockchain Data & Price Charts</title>
  <link rel="canonical" href="https://yourwebsite.com/bitcoin-explorer" />
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Bitcoin Explorer",
      "description": "Advanced Bitcoin blockchain explorer with real-time price charts",
      "applicationCategory": "Blockchain Explorer",
      "operatingSystem": "Web"
    }
  </script>
  <style>
    :root {
      --primary: #f7931a;
      --primary-hover: #e07b0a;
      --secondary: #f0f0f0;
      --text: #333;
      --error: #d32f2f;
      --success: #388e3c;
    }
    
    body { 
      font-family: 'Segoe UI', Arial, sans-serif; 
      max-width: 1000px; 
      margin: 0 auto; 
      padding: 20px; 
      color: var(--text);
      line-height: 1.6;
    }
    
    h1 { color: var(--primary); text-align: center; }
    
    .search-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin: 30px 0;
    }
    
    input, button, select { 
      padding: 10px 12px; 
      font-size: 16px; 
      border-radius: 6px;
      border: 1px solid #ddd;
    }
    
    input { 
      flex: 1; 
      min-width: 250px;
    }
    
    button { 
      cursor: pointer; 
      background: var(--primary); 
      color: white; 
      border: none; 
      font-weight: bold;
      transition: background 0.2s;
    }
    
    button:hover { background: var(--primary-hover); }
    
    .result { 
      background: var(--secondary); 
      padding: 20px; 
      margin-top: 30px; 
      border-radius: 8px; 
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    h2 { margin-top: 30px; color: var(--primary); }
    h3 { margin-top: 20px; }
    
    pre { white-space: pre-wrap; word-wrap: break-word; }
    
    ul { padding-left: 20px; }
    li { margin-bottom: 8px; }
    
    .tx-link { 
      color: var(--primary); 
      text-decoration: none;
      font-family: monospace;
    }
    
    .tx-link:hover { text-decoration: underline; }
    
    .loader {
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--primary);
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .data-row {
      display: flex;
      margin-bottom: 8px;
    }
    
    .data-label {
      font-weight: bold;
      min-width: 180px;
    }
    
    .shorten {
      display: inline-block;
      max-width: 200px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      vertical-align: middle;
    }
    
    .badge {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      margin-left: 8px;
    }
    
    .confirmed { background: var(--success); color: white; }
    .unconfirmed { background: #ff9800; color: white; }
    
    @media (max-width: 600px) {
      .search-container { flex-direction: column; }
      input { width: 100%; }
      .data-row { flex-direction: column; }
      .data-label { min-width: auto; margin-bottom: 4px; }
    }
    
    .copy-btn {
      background: #666;
      padding: 2px 8px;
      font-size: 12px;
      margin-left: 8px;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .copy-btn:hover { background: #555; }
    
    .tabs {
      display: flex;
      border-bottom: 1px solid #ddd;
      margin-bottom: 20px;
    }
    
    .tab {
      padding: 10px 20px;
      cursor: pointer;
      border-bottom: 3px solid transparent;
    }
    
    .tab.active {
      border-bottom-color: var(--primary);
      font-weight: bold;
    }
    
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    
    /* Price chart styles */
    .price-container {
      margin: 40px 0;
      padding: 20px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    
    .price-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .price-info {
      display: flex;
      align-items: center;
    }
    
    .current-price {
      font-size: 24px;
      font-weight: bold;
      color: var(--primary);
    }
    
    .price-change {
      margin-left: 15px;
      padding: 3px 10px;
      border-radius: 4px;
      font-weight: bold;
    }
    
    .positive { background: #e8f5e9; color: var(--success); }
    .negative { background: #ffebee; color: var(--error); }
    
    .timeframe-selector {
      display: flex;
      gap: 10px;
    }
    
    .timeframe-btn {
      padding: 5px 10px;
      background: #eee;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .timeframe-btn.active {
      background: var(--primary);
      color: white;
    }
    
    .chart-container {
      height: 300px;
      width: 100%;
      position: relative;
    }
    
    /* Additional SEO-friendly content */
    .intro-content {
      margin: 20px 0;
      line-height: 1.7;
    }
  </style>
</head>
<body>

  <header>
    <h1>Advanced Bitcoin Explorer</h1>
    <div class="intro-content">
      <p>Explore the Bitcoin blockchain with our comprehensive explorer. View real-time Bitcoin price charts, transaction details, block information, and address tracking. Our tool provides everything you need to analyze the Bitcoin network.</p>
    </div>
  </header>

  <!-- Real-time Price Chart Section -->
  <section class="price-container" aria-label="Bitcoin price chart">
    <div class="price-header">
      <div class="price-info">
        <div class="current-price" id="btc-price">Loading...</div>
        <div class="price-change" id="price-change">24h</div>
      </div>
      <div class="timeframe-selector">
        <button class="timeframe-btn active" onclick="loadPriceChart('24h')">24h</button>
        <button class="timeframe-btn" onclick="loadPriceChart('7d')">7d</button>
        <button class="timeframe-btn" onclick="loadPriceChart('30d')">30d</button>
        <button class="timeframe-btn" onclick="loadPriceChart('1y')">1y</button>
      </div>
    </div>
    <div class="chart-container" id="price-chart">
      <div class="loader"></div>
    </div>
  </section>

  <!-- Blockchain Explorer Section -->
  <section aria-label="Blockchain explorer">
    <div class="search-container">
      <select id="searchType">
        <option value="tx">Transaction (TXID)</option>
        <option value="address">Address</option>
        <option value="block">Block (height or hash)</option>
      </select>
      
      <input type="text" id="searchInput" placeholder="Enter TXID, address or block" aria-label="Search input" />
      
      <button id="searchBtn" onclick="performSearch()">Search</button>
    </div>

    <div id="result" class="result" role="region" aria-live="polite"></div>
  </section>

<script>
  // Simple cache implementation
  const cache = {
    data: {},
    get(key) {
      return this.data[key] || null;
    },
    set(key, value) {
      this.data[key] = value;
      // Remove from cache after 5 minutes
      setTimeout(() => delete this.data[key], 300000);
    }
  };

  // Price chart variables
  let priceChart = null;
  let currentTimeframe = '24h';

  // Initialize the page
  document.addEventListener('DOMContentLoaded', function() {
    loadPriceData();
    loadPriceChart(currentTimeframe);
    
    // Add support for Enter key in search input
    document.getElementById('searchInput').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') performSearch();
    });
  });

  // Formatting functions
  function formatBTC(satoshi) {
    return (satoshi / 1e8).toFixed(8) + ' BTC';
  }
  
  function formatNumber(num) {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
  
  function shortenHash(hash) {
    if (hash.length > 20) {
      return `${hash.substring(0, 10)}...${hash.substring(hash.length - 10)}`;
    }
    return hash;
  }
  
  function copyToClipboard(text) {
    navigator.clipboard.writeText(text).then(() => {
      const btn = document.getElementById('copy-feedback');
      if (btn) {
        btn.textContent = 'Copied!';
        setTimeout(() => btn.textContent = 'Copy', 2000);
      }
    });
  }

  // Input validation
  function validateInput(type, query) {
    if (!query) {
      throw new Error('Please enter a valid value');
    }
    
    if (type === 'tx') {
      if (!/^[a-fA-F0-9]{64}$/.test(query)) {
        throw new Error('Invalid TXID. Must be 64 hexadecimal characters');
      }
    } else if (type === 'address') {
      if (!/^([13][a-km-zA-HJ-NP-Z1-9]{25,34}|bc1[a-z0-9]{39,59})$/.test(query)) {
        throw new Error('Invalid Bitcoin address');
      }
    } else if (type === 'block') {
      if (!/^[0-9]+$/.test(query) && !/^[a-fA-F0-9]{64}$/.test(query)) {
        throw new Error('Invalid block. Enter a number (height) or hash (64 hexadecimal characters)');
      }
    }
  }

  // Main search function
  async function performSearch() {
    const type = document.getElementById('searchType').value;
    const query = document.getElementById('searchInput').value.trim();
    const resultDiv = document.getElementById('result');
    const originalContent = resultDiv.innerHTML;
    
    try {
      validateInput(type, query);
      
      resultDiv.innerHTML = '<div class="loader"></div><p style="text-align:center;">Loading data...</p>';
      
      if (type === 'tx') {
        await searchTransaction(query, resultDiv);
      } else if (type === 'address') {
        await searchAddress(query, resultDiv);
      } else if (type === 'block') {
        await searchBlock(query, resultDiv);
      }
    } catch (e) {
      resultDiv.innerHTML = `<p style="color:var(--error);"><strong>Error:</strong> ${e.message}</p>${originalContent}`;
    }
  }

  // Transaction search
  async function searchTransaction(txid, container) {
    const cachedData = cache.get(`tx_${txid}`);
    if (cachedData) {
      renderTransaction(cachedData, container);
      return;
    }
    
    const [txRes, txStatusRes] = await Promise.all([
      fetch(`https://blockstream.info/api/tx/${txid}`),
      fetch(`https://blockstream.info/api/tx/${txid}/status`)
    ]);
    
    if (!txRes.ok || !txStatusRes.ok) throw new Error('Transaction not found');
    
    const tx = await txRes.json();
    const txStatus = await txStatusRes.json();
    
    tx.status = txStatus;
    cache.set(`tx_${txid}`, tx);
    renderTransaction(tx, container);
  }
  
  function renderTransaction(tx, container) {
    let html = `<h2>Transaction Details</h2>`;
    
    html += `<div class="data-row">
      <div class="data-label">TXID:</div>
      <div>${tx.txid} <button class="copy-btn" onclick="copyToClipboard('${tx.txid}')" id="copy-feedback">Copy</button></div>
    </div>`;
    
    html += `<div class="data-row">
      <div class="data-label">Status:</div>
      <div>${tx.status.confirmed ? 
        `<span class="badge confirmed">Confirmed</span> (Block #${tx.status.block_height})` : 
        `<span class="badge unconfirmed">Unconfirmed</span>`}
      </div>
    </div>`;
    
    if (tx.status.confirmed) {
      html += `<div class="data-row">
        <div class="data-label">Confirmations:</div>
        <div>${formatNumber(tx.status.block_height)}</div>
      </div>`;
    }
    
    html += `<div class="data-row">
      <div class="data-label">Timestamp:</div>
      <div>${tx.status.confirmed ? 
        new Date(tx.status.block_time * 1000).toLocaleString() : 
        'In mempool (unconfirmed)'}
      </div>
    </div>`;
    
    html += `<div class="data-row">
      <div class="data-label">Size:</div>
      <div>${formatNumber(tx.size)} bytes</div>
    </div>`;
    
    // Calculate fee if available
    if (tx.vin && tx.vout) {
      const inputSum = tx.vin.reduce((sum, vin) => sum + (vin.prevout?.value || 0), 0);
      const outputSum = tx.vout.reduce((sum, vout) => sum + vout.value, 0);
      const fee = inputSum - outputSum;
      
      if (fee > 0) {
        html += `<div class="data-row">
          <div class="data-label">Fee:</div>
          <div>${formatBTC(fee)} (${formatNumber(fee)} satoshi)</div>
        </div>`;
        
        html += `<div class="data-row">
          <div class="data-label">Fee rate:</div>
          <div>${(fee / tx.size).toFixed(2)} satoshi/byte</div>
        </div>`;
      }
    }
    
    // Inputs and Outputs tabs
    html += `<div class="tabs">
      <div class="tab active" onclick="switchTab('inputs', 'outputs')">Inputs (${tx.vin.length})</div>
      <div class="tab" onclick="switchTab('outputs', 'inputs')">Outputs (${tx.vout.length})</div>
    </div>`;
    
    // Inputs tab
    html += `<div id="inputs" class="tab-content active"><ul>`;
    tx.vin.forEach((vin, i) => {
      const address = vin.prevout?.scriptpubkey_address || 'Coinbase (new coin generation)';
      const value = vin.prevout?.value ? formatBTC(vin.prevout.value) : 'N/A';
      
      html += `<li>
        <strong>Input #${i + 1}:</strong> 
        ${address.startsWith('Coinbase') ? address : 
          `<a href="#" class="tx-link" onclick="performSearchAddress('${address}')">${address}</a>`}
        - ${value}
        ${vin.txid ? `<br><small>From TX: <a href="#" class="tx-link" onclick="performSearchTx('${vin.txid}')">${shortenHash(vin.txid)}</a></small>` : ''}
      </li>`;
    });
    html += `</ul></div>`;
    
    // Outputs tab
    html += `<div id="outputs" class="tab-content"><ul>`;
    tx.vout.forEach((vout, i) => {
      const address = vout.scriptpubkey_address || 'N/A (non-standard script)';
      html += `<li>
        <strong>Output #${i + 1}:</strong> 
        ${address === 'N/A (non-standard script)' ? address : 
          `<a href="#" class="tx-link" onclick="performSearchAddress('${address}')">${address}</a>`}
        - ${formatBTC(vout.value)}
      </li>`;
    });
    html += `</ul></div>`;
    
    container.innerHTML = html;
  }

  // Address search
  async function searchAddress(address, container) {
    const cachedData = cache.get(`addr_${address}`);
    if (cachedData) {
      renderAddress(cachedData, address, container);
      return;
    }
    
    const [addrRes, txsRes] = await Promise.all([
      fetch(`https://blockstream.info/api/address/${address}`),
      fetch(`https://blockstream.info/api/address/${address}/txs`)
    ]);
    
    if (!addrRes.ok) throw new Error('Address not found');
    
    const addrInfo = await addrRes.json();
    const txs = txsRes.ok ? await txsRes.json() : [];
    
    const data = { addrInfo, txs };
    cache.set(`addr_${address}`, data);
    renderAddress(data, address, container);
  }
  
  function renderAddress(data, address, container) {
    const { addrInfo, txs } = data;
    
    const confirmedBalance = (addrInfo.chain_stats.funded_txo_sum - addrInfo.chain_stats.spent_txo_sum) / 1e8;
    const unconfirmedBalance = (addrInfo.mempool_stats.funded_txo_sum - addrInfo.mempool_stats.spent_txo_sum) / 1e8;
    const totalReceived = addrInfo.chain_stats.funded_txo_sum / 1e8;
    const totalSent = addrInfo.chain_stats.spent_txo_sum / 1e8;
    
    let html = `<h2>Address Details</h2>`;
    
    html += `<div class="data-row">
      <div class="data-label">Address:</div>
      <div>${address} <button class="copy-btn" onclick="copyToClipboard('${address}')" id="copy-feedback">Copy</button></div>
    </div>`;
    
    html += `<div class="data-row">
      <div class="data-label">Confirmed balance:</div>
      <div>${confirmedBalance.toFixed(8)} BTC</div>
    </div>`;
    
    if (unconfirmedBalance !== 0) {
      html += `<div class="data-row">
        <div class="data-label">Unconfirmed balance:</div>
        <div>${unconfirmedBalance.toFixed(8)} BTC</div>
      </div>`;
    }
    
    html += `<div class="data-row">
      <div class="data-label">Total received:</div>
      <div>${totalReceived.toFixed(8)} BTC</div>
    </div>`;
    
    html += `<div class="data-row">
      <div class="data-label">Total sent:</div>
      <div>${totalSent.toFixed(8)} BTC</div>
    </div>`;
    
    html += `<div class="data-row">
      <div class="data-label">Transaction count:</div>
      <div>${formatNumber(addrInfo.chain_stats.tx_count + addrInfo.mempool_stats.tx_count)}</div>
    </div>`;
    
    // Show recent transactions
    html += `<h3>Recent Transactions</h3>`;
    
    if (txs.length === 0) {
      html += `<p>No transactions found</p>`;
    } else {
      html += `<ul>`;
      txs.slice(0, 10).forEach(tx => {
        const isOutgoing = tx.vin.some(vin => vin.prevout?.scriptpubkey_address === address);
        html += `<li>
          <span class="badge ${isOutgoing ? 'unconfirmed' : 'confirmed'}">${isOutgoing ? 'Sent' : 'Received'}</span>
          <a href="#" class="tx-link" onclick="performSearchTx('${tx.txid}')">${shortenHash(tx.txid)}</a>
          (${formatBTC(isOutgoing ? 
            tx.vout.reduce((sum, v) => sum + (v.scriptpubkey_address !== address ? v.value : 0), 0) :
            tx.vout.reduce((sum, v) => sum + (v.scriptpubkey_address === address ? v.value : 0), 0))})
          ${tx.status.confirmed ? 
            `<small>${new Date(tx.status.block_time * 1000).toLocaleDateString()}</small>` : 
            '<small>In mempool</small>'}
        </li>`;
      });
      html += `</ul>`;
    }
    
    container.innerHTML = html;
  }

  // Block search
  async function searchBlock(blockQuery, container) {
    const cachedData = cache.get(`block_${blockQuery}`);
    if (cachedData) {
      renderBlock(cachedData, container);
      return;
    }
    
    let blockHash = blockQuery;
    
    // If it's a number (block height)
    if (/^\d+$/.test(blockQuery)) {
      const hashRes = await fetch(`https://blockstream.info/api/block-height/${blockQuery}`);
      if (!hashRes.ok) throw new Error('Block not found');
      blockHash = await hashRes.text();
    }
    
    const [blockRes, txsRes] = await Promise.all([
      fetch(`https://blockstream.info/api/block/${blockHash}`),
      fetch(`https://blockstream.info/api/block/${blockHash}/txs`)
    ]);
    
    if (!blockRes.ok) throw new Error('Block not found');
    
    const block = await blockRes.json();
    const txs = txsRes.ok ? await txsRes.json() : [];
    
    const data = { block, txs, blockHash };
    cache.set(`block_${blockQuery}`, data);
    cache.set(`block_${blockHash}`, data);
    
    renderBlock(data, container);
  }
  
  function renderBlock(data, container) {
    const { block, txs, blockHash } = data;
    
    let html = `<h2>Block Details</h2>`;
    
    html += `<div class="data-row">
      <div class="data-label">Height:</div>
      <div>${formatNumber(block.height)}</div>
    </div>`;
    
    html += `<div class="data-row">
      <div class="data-label">Hash:</div>
      <div>${blockHash} <button class="copy-btn" onclick="copyToClipboard('${blockHash}')" id="copy-feedback">Copy</button></div>
    </div>`;
    
    html += `<div class="data-row">
      <div class="data-label">Timestamp:</div>
      <div>${new Date(block.timestamp * 1000).toLocaleString()}</div>
    </div>`;
    
    html += `<div class="data-row">
      <div class="data-label">Transaction count:</div>
      <div>${formatNumber(block.tx_count)}</div>
    </div>`;
    
    html += `<div class="data-row">
      <div class="data-label">Size:</div>
      <div>${formatNumber(block.size)} bytes</div>
    </div>`;
    
    html += `<div class="data-row">
      <div class="data-label">Difficulty:</div>
      <div>${formatNumber(Math.round(block.difficulty))}</div>
    </div>`;
    
    html += `<div class="data-row">
      <div class="data-label">Version:</div>
      <div>0x${block.version.toString(16)}</div>
    </div>`;
    
    html += `<div class="data-row">
      <div class="data-label">Merkle Root:</div>
      <div>${block.merkle_root}</div>
    </div>`;
    
    // Block transactions
    html += `<h3>Block Transactions</h3>`;
    
    if (txs.length === 0) {
      html += `<p>No transactions available</p>`;
    } else {
      html += `<ul>`;
      txs.slice(0, 10).forEach(tx => {
        html += `<li>
          <a href="#" class="tx-link" onclick="performSearchTx('${tx.txid}')">${shortenHash(tx.txid)}</a>
          (${formatBTC(tx.vout.reduce((sum, v) => sum + v.value, 0))})
        </li>`;
      });
      html += `</ul>`;
    }
    
    container.innerHTML = html;
  }

  // Price chart functions
  async function loadPriceData() {
    try {
      const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd&include_24hr_change=true');
      const data = await response.json();
      
      const price = data.bitcoin.usd;
      const change24h = data.bitcoin.usd_24h_change;
      
      document.getElementById('btc-price').textContent = `$${price.toLocaleString()}`;
      
      const changeElement = document.getElementById('price-change');
      changeElement.textContent = `${change24h > 0 ? '+' : ''}${change24h.toFixed(2)}%`;
      changeElement.className = `price-change ${change24h >= 0 ? 'positive' : 'negative'}`;
    } catch (error) {
      console.error('Error loading price data:', error);
      document.getElementById('btc-price').textContent = 'Price data unavailable';
    }
  }

  async function loadPriceChart(timeframe) {
    currentTimeframe = timeframe;
    const container = document.getElementById('price-chart');
    container.innerHTML = '<div class="loader"></div>';
    
    // Update active timeframe button
    document.querySelectorAll('.timeframe-btn').forEach(btn => {
      btn.classList.remove('active');
    });
    event.target.classList.add('active');
    
    try {
      // Load chart data from CoinGecko
      let days = '1';
      if (timeframe === '7d') days = '7';
      if (timeframe === '30d') days = '30';
      if (timeframe === '1y') days = '365';
      
      const response = await fetch(`https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=${days}`);
      const data = await response.json();
      
      // Process data for chart
      const prices = data.prices.map(entry => ({
        date: new Date(entry[0]),
        value: entry[1]
      }));
      
      // Render chart (using a simple SVG approach - consider using a library like Chart.js for production)
      renderSimpleChart(prices, container);
    } catch (error) {
      console.error('Error loading price chart:', error);
      container.innerHTML = '<p>Unable to load price chart data</p>';
    }
  }

  function renderSimpleChart(prices, container) {
    if (!prices || prices.length === 0) {
      container.innerHTML = '<p>No chart data available</p>';
      return;
    }
    
    const width = container.clientWidth;
    const height = 300;
    const padding = 20;
    
    // Calculate min/max values
    const values = prices.map(p => p.value);
    const minValue = Math.min(...values);
    const maxValue = Math.max(...values);
    const valueRange = maxValue - minValue;
    
    // Calculate time range
    const minTime = prices[0].date.getTime();
    const maxTime = prices[prices.length - 1].date.getTime();
    const timeRange = maxTime - minTime;
    
    // Create SVG
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", "100%");
    svg.setAttribute("height", height);
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    svg.setAttribute("preserveAspectRatio", "none");
    
    // Create path for price line
    let pathData = '';
    prices.forEach((point, i) => {
      const x = padding + ((point.date.getTime() - minTime) / timeRange) * (width - padding * 2);
      const y = height - padding - ((point.value - minValue) / valueRange) * (height - padding * 2);
      
      if (i === 0) {
        pathData += `M ${x} ${y} `;
      } else {
        pathData += `L ${x} ${y} `;
      }
    });
    
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", pathData);
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", "var(--primary)");
    path.setAttribute("stroke-width", "2");
    svg.appendChild(path);
    
    // Add axes
    const xAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
    xAxis.setAttribute("x1", padding);
    xAxis.setAttribute("y1", height - padding);
    xAxis.setAttribute("x2", width - padding);
    xAxis.setAttribute("y2", height - padding);
    xAxis.setAttribute("stroke", "#666");
    xAxis.setAttribute("stroke-width", "1");
    svg.appendChild(xAxis);
    
    const yAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
    yAxis.setAttribute("x1", padding);
    yAxis.setAttribute("y1", padding);
    yAxis.setAttribute("x2", padding);
    yAxis.setAttribute("y2", height - padding);
    yAxis.setAttribute("stroke", "#666");
    yAxis.setAttribute("stroke-width", "1");
    svg.appendChild(yAxis);
    
    // Add first and last price labels
    const firstPrice = document.createElementNS("http://www.w3.org/2000/svg", "text");
    firstPrice.setAttribute("x", padding + 5);
    firstPrice.setAttribute("y", padding + 15);
    firstPrice.setAttribute("fill", "#666");
    firstPrice.setAttribute("font-size", "12");
    firstPrice.textContent = `$${maxValue.toLocaleString()}`;
    svg.appendChild(firstPrice);
    
    const lastPrice = document.createElementNS("http://www.w3.org/2000/svg", "text");
    lastPrice.setAttribute("x", padding + 5);
    lastPrice.setAttribute("y", height - padding - 5);
    lastPrice.setAttribute("fill", "#666");
    lastPrice.setAttribute("font-size", "12");
    lastPrice.textContent = `$${minValue.toLocaleString()}`;
    svg.appendChild(lastPrice);
    
    container.innerHTML = '';
    container.appendChild(svg);
  }

  // Helper functions for searching from links
  function performSearchTx(txid) {
    document.getElementById('searchType').value = 'tx';
    document.getElementById('searchInput').value = txid;
    performSearch();
  }
  
  function performSearchAddress(address) {
    document.getElementById('searchType').value = 'address';
    document.getElementById('searchInput').value = address;
    performSearch();
  }
  
  function switchTab(showId, hideId) {
    document.getElementById(showId).classList.add('active');
    document.getElementById(hideId).classList.remove('active');
    
    document.querySelector(`.tab[onclick="switchTab('${showId}', '${hideId}')"]`).classList.add('active');
    document.querySelector(`.tab[onclick="switchTab('${hideId}', '${showId}')"]`).classList.remove('active');
  }
</script>

</body>
</html>
